#!/usr/bin/env python
#
# MIT License
#
# Copyright (c) 2017 Vadim Grigoruk @nesbox // grigoruk@gmail.com
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from optparse import OptionParser
import sys
import os
import ninja_syntax

def get_files(path, ext, excludes=[]):
    return [os.path.join(path, filename) for filename in os.listdir(path) if os.path.isfile(os.path.join(path, filename)) and os.path.splitext(filename)[1] == ext and os.path.basename(filename) not in excludes]

def obj(src):
    if not isinstance(src, list):
        src = [src]
    return [ os.path.join('obj', os.path.basename(os.path.splitext(filename)[0] + '.o')) for filename in src ]

def dat(src):
    if not isinstance(src, list):
        src = [src]
    return [ os.path.join('bin/assets', os.path.basename(filename) + '.dat') for filename in src ]

def compile(src, deps=[]):
    for filename in src:
        writer.build(obj(filename), 'cc', filename, deps)

class Platform:
    EMSCRIPTEN='emscripten'
    LINUX='linux'
    WIN='win'
    MACOSX='macosx'

    def __init__(self, platform):
        self._platform = platform or sys.platform

        if self._platform.startswith('linux'):
            self._platform = Platform.LINUX
        elif self._platform.startswith('mingw') or self._platform.startswith('win'):
            self._platform = Platform.WIN
        elif self._platform.startswith('darwin'):
            self._platform = Platform.MACOSX
        elif self._platform.startswith('emscripten'):
            self._platform = Platform.EMSCRIPTEN

    def is_linux(self):
        return self._platform == Platform.LINUX

    def is_emscripten(self):
        return self._platform == Platform.EMSCRIPTEN

    def is_win(self):
        return self._platform == Platform.WIN

    def is_macosx(self):
        return self._platform == Platform.MACOSX

    def known_platforms():
        return [Platform.EMSCRIPTEN, Platform.LINUX, Platform.WIN, Platform.MACOSX]

parser = OptionParser()
parser.add_option('--verbose', action='store_true', help='enable verbose build output')
parser.add_option('--platform', help='target platform (%s)' % ','.join(Platform.known_platforms()), choices=Platform.known_platforms())
parser.add_option('--host', help='host platform (%s)' % ','.join(Platform.known_platforms()), choices=Platform.known_platforms())
parser.add_option('--debug', action='store_true', help='enable debug build')
parser.add_option('--use_llvm', action='store_true', help='use clang as compiler')
parser.add_option('--no_file_dialog', action='store_true', help='disables building the system file dialog')

(options, args) = parser.parse_args()

if args:
    print('ERROR: unsupported arguments:', args)
    sys.exit(-1)

platform = Platform(options.platform)
host = options.host and Platform(options.host) or platform

writer = ninja_syntax.Writer(open('build.ninja', 'w'))

writer.comment('DO NOT EDIT THIS FILE. IT IS GENERATED BY ' + os.path.basename(__file__) + '.')
writer.newline()

writer.variable('ninja_required_version', '1.8.2')
writer.newline()

cc = 'gcc'

if platform.is_emscripten():
    cc = 'emcc'
elif options.use_llvm:
    cc = 'clang'

writer.variable('cc', cc)

includes = ['-Isrc/ext', '-Isrc/ext/lua/src', '-Iinclude/gif', '-Isrc/ext/giflib/lib', '-Isrc/ext/zlib', '-Iinclude/sdl2', '-Iinclude/tic80']
writer.variable('includes', ' '.join(includes))

cflags = ['-Wall', '-std=c99', '$includes'] # TODO: fix warnings and add -Werror

if options.debug:
    cflags.append('-g')
else:
    cflags += ['-O2', '-DNDEBUG']

if options.no_file_dialog:
    cflags.append('-DNO_FILE_DIALOG')

if platform.is_linux():
    cflags += ['-D_GNU_SOURCE']

writer.variable('cflags', ' '.join(cflags))

libs = []

if platform.is_linux():
    libs += ['-lSDL2', '-lm', '-lpthread']

writer.variable('libs', ' '.join(libs))

writer.newline()

writer.rule('cc', command='$cc $cflags -c -o $out $in')
writer.newline()

writer.rule('ld', command='$cc -o $out $in $libs')
writer.newline()

writer.rule('bin2txt', command='bin/bin2txt $in $out -z')
writer.newline()

tic_headers = get_files('include/tic80', '.h') + get_files('src', '.h')
tic_src = get_files('src', '.c')
zlib_src = get_files('src/ext/zlib', '.c')
lua_src = get_files('src/ext/lua/src', '.c', ['lua.c', 'luac.c'])
ext_src = get_files('src/ext', '.c')
duk_src = get_files('src/ext/duktape', '.c')
net_src = get_files('src/ext/net', '.c')
giflib_src = get_files('src/ext/giflib/lib', '.c')
lpeg_src = get_files('src/ext/lpeg', '.c')
bin2txt_src = get_files('tools/bin2txt', '.c')
assets_src = get_files('demos', '.tic')

if platform.is_emscripten():
    assets_src += ['build/html/index.html', 'build/html/tic.js']

for src in assets_src:
    writer.build(dat(src), 'bin2txt', src, 'bin/bin2txt')

tic_deps = zlib_src + duk_src + net_src + ext_src + lua_src + giflib_src + lpeg_src

compile(zlib_src)
compile(duk_src)
compile(net_src)
compile(lua_src)
compile(giflib_src)
compile(lpeg_src)
compile(bin2txt_src, zlib_src)
compile(ext_src, tic_headers)
compile(tic_src, tic_headers + dat(assets_src))

writer.newline()

writer.build('bin/bin2txt', 'ld', obj(bin2txt_src + zlib_src))
writer.newline()

writer.build('bin/tic', 'ld', obj(tic_src + zlib_src + duk_src + net_src + ext_src + lua_src + giflib_src + lpeg_src))
writer.newline()

